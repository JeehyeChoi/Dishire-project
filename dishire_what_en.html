<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dishire — Implemented Features (What)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-color: #f9fafb;
      --accent-color: #7c3aed;
      --accent-light: #ede9fe;
      --text-main: #111827;
      --text-sub: #4b5563;
      --card-bg: #ffffff;
      --border-color: #e5e7eb;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #eef2ff 0, #f9fafb 40%, #ffffff 100%);
      color: var(--text-main);
      line-height: 1.7;
    }

    main.page {
      min-height: 100vh;
      padding: 3rem 1.5rem 4rem;
      display: flex;
      justify-content: center;
    }

    .container { width: 100%; max-width: 880px; }

    .breadcrumb {
      font-size: 0.85rem;
      color: #6b7280;
      margin-bottom: 1.2rem;
    }

    .breadcrumb a {
      color: #6b7280;
      text-decoration: none;
    }

    .breadcrumb a:hover { text-decoration: underline; }

    h1 {
      font-size: clamp(1.9rem, 3vw, 2.2rem);
      letter-spacing: -0.03em;
      margin-bottom: 1rem;
    }

    h1 span { color: var(--accent-color); }

    .subtitle {
      font-size: 1rem;
      color: var(--text-sub);
      margin-bottom: 2.2rem;
      max-width: 720px;
    }

    section.block {
      margin-bottom: 2.4rem;
      padding: 1.6rem 1.8rem;
      border-radius: 1.5rem;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(209, 213, 219, 0.8);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.06);
    }

    section.block h2 {
      font-size: 1.15rem;
      margin-bottom: 0.8rem;
      letter-spacing: -0.02em;
    }

    section.block h3 {
      font-size: 1rem;
      margin-top: 1.1rem;
      margin-bottom: 0.5rem;
      letter-spacing: -0.01em;
      color: #111827;
    }

    section.block p {
      font-size: 0.95rem;
      color: var(--text-sub);
      margin-bottom: 0.5rem;
    }

    ul {
      margin: 0.2rem 0 0.7rem 1.1rem;
      padding-left: 0.6rem;
    }

    li {
      font-size: 0.94rem;
      color: var(--text-sub);
      margin-bottom: 0.3rem;
    }

    .screenshot {
      margin-top: 1.1rem;
      text-align: center;
    }

    .screenshot img {
      width: 100%;
      max-width: 480px;
      border-radius: 1.2rem;
      border: 1px solid #e5e7eb;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
    }

    .page-nav {
      margin-top: 2.4rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .page-nav a {
      color: var(--accent-color);
      text-decoration: none;
      font-weight: 600;
    }

    .page-nav a:hover { text-decoration: underline; }

    /* Language switch */
    .top-bar {
      width: 100%;
      position: fixed;
      top: 0;
      right: 0;
      padding: 14px 18px;
      display: flex;
      justify-content: flex-end;
      z-index: 100;
    }

    .lang-switch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      color: #6b7280;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(148,163,184,0.35);
      backdrop-filter: blur(10px);
      padding: 6px 10px;
      border-radius: 999px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
    }

    .lang-switch a {
      text-decoration: none;
      color: #6b7280;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .lang-switch a.active {
      color: #7c3aed;
      font-weight: 600;
      background: rgba(124, 58, 237, 0.10);
      border-color: rgba(124, 58, 237, 0.22);
    }
  </style>
</head>

<body>
  <main class="page">
    <!-- Language switch -->
    <div class="top-bar">
      <div class="lang-switch">
        <span>Language:</span>
        <a href="dishire_what.html">한국어</a>
        <a href="dishire_what_en.html" class="active">ENG</a>
      </div>
    </div>

    <div class="container">
      <div class="breadcrumb">
        <a href="dishire_hero_en.html">Dishire</a> · Implemented Features (What)
      </div>

      <h1><span>Dishire</span> — What Was Implemented in the Prototype</h1>

      <p class="subtitle">
        This page summarizes the features that were actually implemented in the Dishire prototype:
        context-based recommendation types, a multi-step LLM recipe generation flow, profile-based constraints,
        and the end-to-end UI flow.
      </p>

      <!-- 1. Summary -->
      <section class="block">
        <h2>1. Core Features (Prototype Summary)</h2>
        <ul>
          <li>Defined recommendation types and generated recipes using prompt templates</li>
          <li>Implemented a multi-step LLM pipeline (title → ingredients → tools → step-by-step cooking)</li>
          <li>Injected user profile constraints (diet, allergies, religion) into LLM inputs</li>
          <li>Built an end-to-end prototype with FastAPI backend + React UI</li>
        </ul>
      </section>

      <!-- 2. Multi-step generation -->
      <section class="block">
        <h2>2. Multi-step LLM Recipe Generation</h2>

        <p>
          Generating an entire recipe in a single call often increased response time and prompt length.
          It also made it hard to experiment with combining different GPT model choices for cost control.
          For these reasons, the Dishire prototype explored splitting the recipe into multiple calls.
          This was an experiment to understand practical trade-offs rather than claiming that multi-step is always better.
        </p>

        <p>
          In particular, Step 1 generates only the high-level direction (title and short description),
          so the user can quickly decide whether the direction fits their preference.
          If not, the user can re-try early, which can reduce unnecessary generation cost.
        </p>

        <p>
          Subsequent steps generate details such as ingredients/tools and step-by-step instructions.
          The prototype did not implement ingredient substitution based on preference history,
          but it was considered a natural extension (e.g., suggesting substitutes based on repeated user choices).
        </p>

        <ul>
          <li><strong>Step 1:</strong> Title, short description, difficulty, estimated time</li>
          <li><strong>Step 2:</strong> Ingredients list, required cooking tools</li>
          <li><strong>Step 3:</strong> Step-by-step cooking instructions</li>
          <li><strong>Step 4:</strong> How to eat, tips, storage, generative image</li>
        </ul>

        <p>
          The generation flow was implemented as API endpoints in a FastAPI backend.
          The React UI sends step-wise requests and assembles the final recipe output for display.
        </p>
      </section>

      <!-- 3. Context-based routing -->
      <section class="block">
        <h2>3. Context-based Recommendation Flow</h2>

        <p>
          In the prototype, the user explicitly selects a recommendation mode
          (e.g., “standard”, “ingredient-based”), and the corresponding prompt template is executed.
          This initial structure was designed to test whether situation-aware routing is useful in practice.
        </p>

        <p>
          The longer-term goal was to <strong>automatically choose an appropriate prompt template</strong>
          by analyzing user input text and profile constraints.
          For example, “I only have mushrooms” could route to ingredient-based prompting,
          while “I only have 10 minutes” could route to time/difficulty prompting.
          The prototype did not implement this automatic classification step,
          but it established the template-level structure needed for that future direction.
        </p>

        <h3>Recommendation Modes Implemented in the Prototype</h3>
        <ul>
          <li>
            <strong>Standard recommendation</strong> — a general prompt template designed to return a stable recipe regardless of context.
          </li>
          <li>
            <strong>Ingredient-based</strong> — a template that focuses on user-provided ingredients to generate plausible dishes.
          </li>
          <li>
            <strong>Context-based</strong> — a template that reflects simple constraints such as time and difficulty (e.g., “under 10 minutes”).
          </li>
        </ul>

        <p>
          This modular design was an early step toward a pipeline of
          <strong>user intent → routing → prompt selection → recipe generation</strong>.
        </p>
      </section>

      <!-- 4. Profile constraints -->
      <section class="block">
        <h2>4. User Profile Constraints</h2>
        <p>
          Beyond simple context input, Dishire experimented with using user profile constraints
          to generate more personalized recipes.
        </p>
        <ul>
          <li>Diet preferences (vegan, low-carb, low-sodium, etc.)</li>
          <li>Allergies (e.g., nut allergy)</li>
          <li>Religious dietary rules (e.g., halal, kosher)</li>
        </ul>
        <p>
          These constraints were embedded into prompt templates so the LLM could consider them during generation.
        </p>
      </section>

      <!-- 5. UI -->
      <section class="block">
        <h2>5. UI Prototype</h2>
        <p>
          The prototype UI was built with React, supporting a basic end-to-end flow:
          select a recommendation mode, request a recipe, and review the generated output.
        </p>

        <div class="screenshot">
          <img src="chatview_chat.png" alt="Dishire UI prototype screenshot" />
        </div>
      </section>

      <div class="page-nav">
        <a href="dishire_why_en.html">← Previous: Background (Why)</a>
        <a href="dishire_how_en.html">Next: System Design (How) →</a>
      </div>
    </div>
  </main>
</body>
</html>
